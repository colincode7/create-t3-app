---
title: tRPC
description: Uso do tRPC
layout: ../../../layouts/docs.astro
lang: pt
---

O tRPC nos permite escrever APIs seguras de ponta a ponta sem nenhuma geraÃ§Ã£o de cÃ³digo ou sobrecarga de tempo de execuÃ§Ã£o. Ele usa a grande inferÃªncia do TypeScript para inferir as definiÃ§Ãµes de tipo do seu roteador de API e permite que vocÃª chame seus procedimentos de API de seu front-end com total seguranÃ§a de tipo e preenchimento automÃ¡tico. Ao usar tRPC, seu front-end e back-end parecem mais prÃ³ximos do que nunca, permitindo uma excelente experiÃªncia de desenvolvedor.

<blockquote className="w-full relative border-l-4 italic bg-t3-purple-200 dark:text-t3-purple-50 text-zinc-900 dark:bg-t3-purple-300/20 p-2 rounded-md text-sm my-3 border-neutral-500 quote">
  <div className="relative w-fit flex items-center justify-center p-1">
    <p className="mb-4 text-lg">
      <span aria-hidden="true">&quot;</span>Criei o tRPC para permitir que as pessoas se movam mais rapidamente, removendo a necessidade de uma camada de API tradicional, enquanto ainda tenho a confianÃ§a de que nossos aplicativos nÃ£o serÃ£o interrompidos Ã  medida que iteramos rapidamente.<span aria-hidden="true">&quot;</span>
      <small aria-hidden="true">(traduzido)</small>
    </p>
  </div>
  <cite className="flex items-center justify-end pr-4 pb-2">
    <img
      alt="Avatar of @alexdotjs"
      className="w-12 mr-4 rounded-full bg-neutral-500"
      src="https://avatars.githubusercontent.com/u/459267?v=4"
    />
    <div className="flex flex-col items-start not-italic">
      <span className=" text-sm font-semibold">Alex - criador do tRPC</span>
      <a
        href="https://twitter.com/alexdotjs"
        target="_blank"
        rel="noopener noreferrer"
        className="text-sm"
      >
        @alexdotjs
      </a>
    </div>
  </cite>
</blockquote>

## Files

O tRPC requer bastante do template que o `create-t3-app` configura para vocÃª. Vamos ver os arquivos que sÃ£o gerados:

### ğŸ“„ `pages/api/trpc/[trpc].ts`

Este Ã© o ponto de entrada para sua API que expÃµe o roteador tRPC. Normalmente, vocÃª nÃ£o mexerÃ¡ muito nesse arquivo, mas se precisar, por exemplo, habilitar o middleware CORS ou similar, Ã© Ãºtil saber que o `createNextApiHandler` exportado Ã© um [handler da API do Next.js](https://nextjs.org/docs/api-routes/introduction) que recebe uma [request](https://developer.mozilla.org/en-US/docs/Web/API/Request) e [response](https://developer.mozilla.org/en-US/docs/Web/API/Response). Isso significa que vocÃª pode agrupar o `createNextApiHandler` em qualquer middleware que desejar. Veja abaixo um [trecho de exemplo](#ativando-o-cors) da adiÃ§Ã£o de CORS.

### ğŸ“„ `server/trpc/context.ts`

Este arquivo Ã© onde vocÃª define o contexto que Ã© passado para seus procedimentos tRPC. Contexto sÃ£o dados aos quais todos os seus procedimentos tRPC terÃ£o acesso e Ã© um Ã³timo lugar para colocar coisas como conexÃµes de banco de dados, informaÃ§Ãµes de autenticaÃ§Ã£o, etc. No create-t3-app, usamos duas funÃ§Ãµes, para habilitar o uso de um subconjunto do contexto quando nÃ£o temos acesso ao objeto de solicitaÃ§Ã£o.

- `createContextInner`: Ã‰ aqui que vocÃª define o contexto que nÃ£o depende da solicitaÃ§Ã£o, por exemplo sua conexÃ£o com o banco de dados. VocÃª pode usar esta funÃ§Ã£o para [teste de integraÃ§Ã£o](#exemplo-de-teste-de-integraÃ§Ã£o) ou [ssg-helpers](https://trpc.io/docs/v10/ssg-helpers) onde vocÃª nÃ£o tem um objeto de solicitaÃ§Ã£o/request.

- `createContext`: Ã‰ aqui que vocÃª define o contexto que depende da solicitaÃ§Ã£o, por exemplo a sessÃ£o do usuÃ¡rio. VocÃª solicita a sessÃ£o usando o objeto `opts.req` e, em seguida, passa a sessÃ£o para a funÃ§Ã£o `createContextInner` para criar o contexto final.

### ğŸ“„ `server/trpc/trpc.ts`

Ã‰ aqui que vocÃª inicializa tRPC e define [procedimentos reutilizÃ¡veis](https://trpc.io/docs/v10/procedures) e [middlewares](https://trpc.io/docs/v10/middlewares). Por convenÃ§Ã£o, vocÃª nÃ£o deve exportar todo o objeto `t`, mas, em vez disso, criar procedimentos e middlewares reutilizÃ¡veis e exportÃ¡-los.

VocÃª notarÃ¡ que usamos `superjson` como [transformador de dados](https://trpc.io/docs/v10/data-transformers). Isso faz com que seus tipos de dados sejam preservados quando chegam ao cliente, portanto, se vocÃª, por exemplo, enviar um objeto `Data`, o cliente retornarÃ¡ uma `Data` e nÃ£o uma string, como Ã© o caso da maioria das APIs.

### ğŸ“„ `server/trpc/router/*.ts`

Ã‰ aqui que vocÃª define as rotas e procedimentos da sua API. Por convenÃ§Ã£o, vocÃª [cria roteadores separados](https://trpc.io/docs/v10/router) para procedimentos relacionados e [mescla](https://trpc.io/docs/v10/merging-routers) todos deles em um Ãºnico roteador de aplicativo em `server/trpc/router/_app.ts`.

### ğŸ“„ `utils/trpc.ts`

Este Ã© o ponto de entrada do front-end para tRPC. Ã‰ aqui que vocÃª importarÃ¡ a **definiÃ§Ã£o de tipo** do roteador e criarÃ¡ seu cliente tRPC junto com os hooks do react-query. Como habilitamos `superjson` como nosso transformador de dados no back-end, precisamos habilitÃ¡-lo tambÃ©m no front-end. Isso ocorre porque os dados serializados do back-end sÃ£o "desserializados" no front-end.

VocÃª definirÃ¡ seus [links tRPC](https://trpc.io/docs/v10/links) aqui, que determinarÃ£o o fluxo de solicitaÃ§Ã£o do cliente para o servidor. Usamos o "padrÃ£o" [`httpBatchLink`](https://trpc.io/docs/v10/links/httpBatchLink) que permite [solicitar lotes](https://cloud.google.com/compute/docs/api/how-tos/batch), bem como um [`loggerLink`](https://trpc.io/docs/v10/links/loggerLink) que gera logs de solicitaÃ§Ã£o Ãºteis durante o desenvolvimento.

Por fim, exportamos um [tipo auxiliar](https://trpc.io/docs/v10/infer-types#additional-dx-helper-type) que vocÃª pode usar para inferir seus tipos no frontend.

## Como eu uso o tRPC?

<div class="embed">
<iframe width="560" height="315" src="https://www.youtube.com/embed/2LYM8gf184U" title="Making typesafe APIs easy with tRPC" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

o contribuidor do tRPC [trashh_dev](https://twitter.com/trashh_dev) fez [uma fala esplÃªndida na Next.js Conf](https://www.youtube.com/watch?v=2LYM8gf184U) sobre o tRPC. Ã‰ altamente recomendÃ¡vel que vocÃª assista, caso ainda nÃ£o o tenha feito.

Com tRPC, vocÃª escreve funÃ§Ãµes TypeScript em seu back-end e, em seguida, as chama de seu front-end. Um procedimento tRPC simples poderia ser assim:

```ts:server/trpc/router/user.ts
const userRouter = t.router({
  getById: t.procedure.input(z.string()).query(({ ctx, input }) => {
    return ctx.prisma.user.findFirst({
      where: {
        id: input,
      },
    });
  }),
});
```

Este Ã© um procedimento tRPC (equivalente a um manipulador de rota em um back-end tradicional) que primeiro valida a entrada usando Zod (que Ã© a mesma biblioteca de validaÃ§Ã£o que usamos para [variÃ¡veis de ambiente](./env-variables)) - neste caso , Ã© garantir que a entrada seja uma string. Se a entrada nÃ£o for uma string, ela enviarÃ¡ um erro informativo.

ApÃ³s a entrada, encadeamos uma funÃ§Ã£o de resoluÃ§Ã£o que pode ser uma [consulta](https://trpc.io/docs/v10/react-queries), [mutaÃ§Ã£o](https://trpc.io/docs/v10/react-mutations) ou uma [assinatura](https://trpc.io/docs/v10/subscriptions). Em nosso exemplo, o resolvedor chama nosso banco de dados usando nosso cliente [prisma](./prisma) e retorna o usuÃ¡rio cujo `id` corresponde ao que passamos.

VocÃª define seus procedimentos em `routers` que representam uma coleÃ§Ã£o de procedimentos relacionados com um namespace compartilhado. VocÃª pode ter um roteador para `users`, um para `posts` e outro para `messages`. Esses roteadores podem ser mesclados em um Ãºnico `appRouter` centralizado:

```ts:server/trpc/router/_app.ts
const appRouter = t.router({
  users: userRouter,
  posts: postRouter,
  messages: messageRouter,
});

export type AppRouter = typeof appRouter;
```

Observe que precisamos apenas exportar as definiÃ§Ãµes de tipo do nosso roteador, o que significa que nunca importaremos nenhum cÃ³digo de servidor em nosso cliente.

Agora vamos chamar o procedimento em nosso frontend. tRPC fornece um wrapper para o `@tanstack/react-query` que permite que vocÃª utilize todo o poder dos hooks que eles fornecem, mas com o benefÃ­cio adicional de ter suas chamadas de API digitadas e inferidas. Podemos chamar nossos procedimentos de nosso front-end assim:

```tsx:pages/users/[id].tsx
import { useRouter } from "next/router";

const UserPage = () => {
  const { query } = useRouter();
  const userQuery = trpc.user.getById.useQuery(query.id);

  return (
    <div>
      <h1>{userQuery.data?.name}</h1>
    </div>
  );
};
```

VocÃª notarÃ¡ imediatamente como o preenchimento automÃ¡tico e a seguranÃ§a de tipo sÃ£o bons. Assim que vocÃª escrever `trpc.`, seus roteadores aparecerÃ£o no preenchimento automÃ¡tico, e quando vocÃª selecionar um roteador, seus procedimentos tambÃ©m aparecerÃ£o. VocÃª tambÃ©m receberÃ¡ um erro de TypeScript se sua entrada nÃ£o corresponder ao validador definido no back-end.

## Como faÃ§o para chamar minha API externamente?

Com APIs regulares, vocÃª pode chamar seus endpoints usando qualquer cliente HTTP, como `curl`, `Postman`, `fetch`, `Insomnia` ou diretamente do seu navegador. Com tRPC, Ã© um pouco diferente. Se vocÃª deseja chamar seus procedimentos sem o cliente tRPC, hÃ¡ duas maneiras recomendadas de fazer isso:

### Expor um Ãºnico procedimento externamente

Se vocÃª deseja expor um Ãºnico procedimento externamente, estÃ¡ procurando por [chamadas do lado do servidor](https://trpc.io/docs/v10/server-side-calls). Isso permitiria que vocÃª criasse um terminal de API Next.js normal, mas reutilizasse a parte do resolvedor de seu procedimento tRPC.

```ts:pages/api/users/[id].ts
import type { NextApiRequest, NextApiResponse } from "next";
import { appRouter } from "../../../server/trpc/router/_app";
import { createContext } from "../../../server/trpc/context";

const userByIdHandler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Criar contexto e chamador (caller)
  const ctx = await createContext({ req, res });
  const caller = appRouter.createCaller(ctx);
  try {
    const { id } = req.query;
    const user = await caller.user.getById(id);
    res.status(200).json(user);
  } catch (cause) {
    if (cause instanceof TRPCError) {
      // Ocorreu um erro do tRPC
      const httpCode = getHTTPStatusCodeFromError(cause);
      return res.status(httpCode).json(cause);
    }
    // Ocorreu outro erro
    console.error(cause);
    res.status(500).json({ message: "Internal server error" });
  }
};

export default userByIdHandler;
```

### Expondo cada procedimento como um endpoint REST

Se vocÃª deseja expor todos os procedimentos externamente, verifique o plug-in criado pela comunidade [trpc-openapi](https://github.com/jlalmes/trpc-openapi/tree/master). Ao fornecer alguns metadados extras para seus procedimentos, vocÃª pode gerar uma API REST compatÃ­vel com OpenAPI a partir de seu roteador tRPC.

### SÃ£o apenas Requests HTTP

O tRPC se comunica por meio de HTTP, portanto, tambÃ©m Ã© possÃ­vel chamar seus procedimentos tRPC usando solicitaÃ§Ãµes HTTP "regulares". No entanto, a sintaxe pode ser complicada devido ao [protocolo RPC](https://trpc.io/docs/v10/rpc) que o tRPC usa. Se vocÃª estiver curioso, pode verificar como sÃ£o as solicitaÃ§Ãµes e respostas tRPC na guia de rede do seu navegador, mas sugerimos fazer isso apenas como um exercÃ­cio educacional e aderir a uma das soluÃ§Ãµes descritas acima.

## ComparaÃ§Ã£o com um endpoint da API Next.js

Vamos comparar um endpoint da API Next.js com um procedimento tRPC. Digamos que queremos buscar um objeto de usuÃ¡rio de nosso banco de dados e retornÃ¡-lo ao frontend. PoderÃ­amos escrever uma rota de API Next.js como esta:

```ts:pages/api/users/[id].ts
import type { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../server/db/client";

const userByIdHandler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== "GET") {
    return res.status(405).end();
  }

  const { id } = req.query;

  if (!id || typeof id !== "string") {
    return res.status(400).json({ error: "Invalid id" });
  }

  const examples = await prisma.example.findFirst({
    where: {
      id,
    },
  });

  res.status(200).json(examples);
};

export default userByIdHandler;
```

```ts:pages/users/[id].tsx
import { useState, useEffect } from "react";
import { useRouter } from "next/router";

const UserPage = () => {
  const router = useRouter();
  const { id } = router.query;

  const [user, setUser] = useState(null);
  useEffect(() => {
    fetch(`/api/user/${id}`)
      .then((res) => res.json())
      .then((data) => setUser(data));
  }, [id]);
};
```

Compare isso com o exemplo tRPC acima e vocÃª verÃ¡ algumas das vantagens do tRPC:

- Em vez de especificar um URL para cada rota, o que pode ser irritante de depurar se vocÃª mover algo, todo o seu roteador Ã© um objeto com preenchimento automÃ¡tico.
- VocÃª nÃ£o precisa validar qual mÃ©todo HTTP foi usado.
- VocÃª nÃ£o precisa validar se a consulta ou o corpo da solicitaÃ§Ã£o contÃ©m os dados corretos no procedimento, pois o Zod cuida disso.
- Em vez de criar uma resposta, vocÃª pode lanÃ§ar erros e retornar um valor ou objeto como faria em qualquer outra funÃ§Ã£o TypeScript.
- Chamar o procedimento no frontend fornece preenchimento automÃ¡tico e seguranÃ§a de tipo.

## Snippets Ãºteis

Aqui estÃ£o alguns snippets que podem ser Ãºteis.

### Ativando o CORS

Se vocÃª precisar consumir sua API de um domÃ­nio diferente, por exemplo, em um monorepo que inclua um aplicativo React Native, talvez seja necessÃ¡rio habilitar o CORS:

```ts:pages/api/trpc/[trpc].ts
import type { NextApiRequest, NextApiResponse } from "next";
import { createNextApiHandler } from "@trpc/server/adapters/next";
import { appRouter } from "~/server/trpc/router/_app";
import { createContext } from "~/server/trpc/context";
import cors from "nextjs-cors";

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Ativar CORS
  await cors(req, res);

  // Criar e chamar o handler do tRPC
  return createNextApiHandler({
    router: appRouter,
    createContext,
  })(req, res);
};

export default handler;
```

### AtualizaÃ§Ãµes otimistas

As atualizaÃ§Ãµes otimistas ocorrem quando atualizamos a interface do usuÃ¡rio antes que a chamada da API seja concluÃ­da. Isso dÃ¡ ao usuÃ¡rio uma experiÃªncia melhor porque ele nÃ£o precisa esperar que a chamada da API termine antes que a interface do usuÃ¡rio reflita o resultado de sua aÃ§Ã£o. No entanto, aplicativos que valorizam muito a exatidÃ£o dos dados devem evitar atualizaÃ§Ãµes otimistas, pois nÃ£o sÃ£o uma representaÃ§Ã£o "verdadeira" do estado de back-end. VocÃª pode ler mais na [documentaÃ§Ã£o do React Query](https://tanstack.com/query/v4/docs/guides/optimistic-updates).

```tsx
const MyComponent = () => {
  const listPostQuery = trpc.post.list.useQuery();

  const utils = trpc.useContext();
  const postCreate = trpc.post.create.useMutation({
    async onMutate(newPost) {
      // Cancele as buscas de saÃ­da (para que nÃ£o substituam nossa atualizaÃ§Ã£o otimista)
      await utils.post.list.cancel();

      // Obtenha os dados do queryCache
      const prevData = utils.post.list.getData();

      // Atualizar os dados de forma otimista com nosso novo post
      utils.post.list.setData(undefined, (old) => [...old, newPost]);

      // Retornar os dados anteriores para que possamos reverter se algo der errado
      return { prevData };
    },
    onError(err, newPost, ctx) {
      // Se a mutation falhar, usar o valor de contexto de onMutate
      utils.post.list.setData(undefined, ctx.prevData);
    },
    onSettled() {
      // Sincronizar com o servidor assim que a mutaÃ§Ã£o for estabelecida
      utils.post.list.invalidate();
    },
  });
};
```

### Exemplo de teste de integraÃ§Ã£o

Aqui estÃ¡ um exemplo de teste de integraÃ§Ã£o que usa [Vitest](https://vitest.dev) para verificar se seu roteador tRPC estÃ¡ funcionando conforme o esperado, se o analisador de entrada infere o tipo correto e se os dados retornados correspondem Ã  saÃ­da esperada.

```ts
import { type inferProcedureInput } from "@trpc/server";
import { createContextInner } from "~/server/router/context";
import { appRouter, type AppRouter } from "~/server/router/_app";
import { expect, test } from "vitest";

test("example router", async () => {
  const ctx = await createContextInner({ session: null });
  const caller = appRouter.createCaller(ctx);

  type Input = inferProcedureInput<AppRouter["example"]["hello"]>;
  const input: Input = {
    text: "test",
  };

  const example = await caller.example.hello(input);

  expect(example).toMatchObject({ greeting: "Hello test" });
});
```

## Recursos Ãšteis

| Recurso                     | Link                                                    |
| --------------------------- | ------------------------------------------------------- |
| DocumentaÃ§Ã£o do tRPC        | https://www.trpc.io                                     |
| Muitos exemplos de tRPC     | https://github.com/trpc/trpc/tree/next/examples         |
| DocumentaÃ§Ã£o do React Query | https://tanstack.com/query/v4/docs/adapters/react-query |
